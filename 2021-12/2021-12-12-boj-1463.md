# <center>[백준 문제풀이] 1463번 1로 만들기</center>

---

## 1463번 1로 만들기

## 문제

정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지 이다.

X가 3으로 나누어 떨어지면, 3으로 나눈다.
X가 2로 나누어 떨어지면, 2로 나눈다.
1을 뺀다.
정수 N이 주어졌을 때, 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하시오.

## 입력

첫째 줄에 1보다 크거나 같고, 106보다 작거나 같은 정수 N이 주어진다.

## 출력

첫째 줄에 연산을 하는 횟수의 최솟값을 출력한다.

## 다이나믹 프로그래밍

### 필요조건

1. 하나의 Problem을 여러개의 SubProblem으로 나눌 수 있다.
2. SubProblem의 솔루션으로 더 큰 Problem의 솔루션을 구할 수 있을 때.
3. 이러한 SubProblem들이 서로 겹칠 때.

### 예시) 피보나치 수열

1. N의 값을 구하기 위해 N – 1과 N – 2를 구해주어야한다. (Problem을 Subproblem으로 나눌 수 있다,)
2. N – 1과 N – 2의 값으로 N의 값을 구할 수 있다. (Subproblem의 값으로 Problem의 값을 구할 수 있다.)
3. N – 1을 구하기 위해서는 N – 2, N – 3의 값이 필요하다. (Subproblem이 겹친다. => 중복되는 계산을 줄일 수 있다.)

### Subproblem의 솔루션을 Array로 만들어서 Problem의 솔루션이 필요할 때 거기서 꺼내 쓴다.

recursive DP => 재귀함수 + Subproblem의 솔루션을 Array에 저장
==> 큰 수를 구하려면 Stacksize overflow가 생길 수 있다.
bottomUp DP => 반복문을 사용해서 아래부터 Array를 만들어서 해결한다.

Dynamic Programming에서 제일 어려운 것은 Problem과 Subproblem을 정의하는 것이다.

## 첫 번째 풀이

=> 1을 최종 답으로 정하고, 1에서 파생될 수 있는 경우의 수 배열을 만들어서 풀었다.
내가 푼 풀이가 남들보다 느려서(396ms) 다른 사람들의 풀이를 보니 배열을 미리 만드는 것이 시간 단축에 더 도움이 될 수 있다는 생각을 할 수 있었다.

배열을 미리 만드니 260ms로 단축되었다.

더 빠른 풀이(204ms)를 보니, 3을 곱할지 2를 곱할지 1을 더할지에 대한 분기점에서 조건문을 주어서 모든 조건에 같은 방식으로 하지 않고 조건에 맞는 알고리즘으로 효율을 높혔다.
