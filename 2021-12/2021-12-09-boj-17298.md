# <center>[백준 문제풀이] 17298번 오큰수</center>

---

## 17298번 오큰수

## 문제

크기가 N인 수열 A = A1, A2, ..., AN이 있다. 수열의 각 원소 Ai에 대해서 오큰수 NGE(i)를 구하려고 한다. Ai의 오큰수는 오른쪽에 있으면서 Ai보다 큰 수 중에서 가장 왼쪽에 있는 수를 의미한다. 그러한 수가 없는 경우에 오큰수는 -1이다.

예를 들어, A = [3, 5, 2, 7]인 경우 NGE(1) = 5, NGE(2) = 7, NGE(3) = 7, NGE(4) = -1이다. A = [9, 5, 4, 8]인 경우에는 NGE(1) = -1, NGE(2) = 8, NGE(3) = 8, NGE(4) = -1이다.

## 입력

첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000,000)이 주어진다. 둘째 줄에 수열 A의 원소 A1, A2, ..., AN (1 ≤ Ai ≤ 1,000,000)이 주어진다.

## 출력

총 N개의 수 NGE(1), NGE(2), ..., NGE(N)을 공백으로 구분해 출력한다.

## 첫 번째 풀이

=> 이 문제에 대해서 객체형 Queue도 생각해보고 stack을 두 개 만들어보는 등 여러 가지를 꽤 오래 고민했는데 시간내에 풀 방법이 없었다. 나는 아직 골드가 되기엔 정말 부족하다는 것을 받아들이고 다른 사람들의 풀이를 보았다.

stack의 성질을 더 이용해야하고, 훨씬 더 유연하게 사고해야 한다는 것을 배울 수 있었다. 해시 탐색을 한다는 것은 객체를 생성해서 하는 것만 있는 것이 아니었고, 내가 하려던 것은 결국 전부 완전 탐색이었다.

stack에 각 값의 index 값만 넣은 뒤 현재의 값이 이전 값보다 크면, 이전 값들을 전부 현재의 값으로 바꿔주는 알고리즘이었는데 읽으면서 감탄했다. 누군가에게는 너무 쉽고 기초적일 수도 있겠지만, 지금의 나에게는 정말 섹시한 코드였다.

접근도 못하고 찾아봐야 했던 것이 참 부끄러워서, 내용을 이해한 뒤 정리해서 구현은 직접해보기로 했다.

추가로 안 것 : const로 함수를 선언하면 호이스팅 되지 않는다.
