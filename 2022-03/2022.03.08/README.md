# 2630번 색종이 만들기

---

## 분할정복 알고리즘

목표 설정 알고리즘을 만드는 중, 분할 정복 알고리즘을 공부할 필요가 있다고 생각되었다.

분할정복 알고리즘이 주는 느낌은 동적계획법과 유사했다.

달랐던 점은 동적계획법은 Sub problem의 해를 통해 Main problem에 접근하는 반면, 분할정복은 나눌 수 없을때까지 나눈다는 점이었다.

여기까지 정리한 다음 실제 차이가 어떤지 찾아보았다.

## 분할정복 알고리즘과 동적계획법

### 1. 동적계획법

#### 1) 동적계획법이란

동적계획법의 경우는 위에서 서술한 듯이 작은 부분 문제들을 해결한 후, 해당 부분 문제의 해를 활용해서 보다 큰 문제를 해결해서 전체 문제를 해결하는 알고리즘이다.

#### 2) Memoization(메모이제이션)이란

또한, 동적계획법을 이해할 때 매우 중요한 것은 Memoization 기법이었다. Sub problem들의 해를 저장해서 다시 실행하지 않도록 하여서 실행속도를 빠르게 하는 기술이었다.

#### 3) 동적 계획법의 쓰임새

즉, 동적계획법은 Main Problem을 Sub problem들로 나눌 수 있고, 이러한 Sub problem의 해는 '반복'되어서 '재사용'이 필요할 때 사용된다.

ex) 피보나치 수열(n 값을 구하기 위해 n - 1, n - 2의 해를 구해야함.)

#### 4) 동적 계획법 알고리즘의 유의점

##### 인간이 아닌, 컴퓨터가 알아들을 수 있는 점화식을 세워야함.

내가 동적 알고리즘으로 문제에 접근할 때 종종 실수하는 점은 인간의 뇌로 문제에 접근하려고 하는 점이다.

인간의 뇌로 동적계획법을 수행하려 하면, 자꾸 Main problem을 먼저 풀려고 하게 되었는데 동적계획법은 재귀의 방법을 사용해야하기 때문에 Main problem을 '반복'되는 Sub problem들로 쪼갤 수 있는 점화식을 찾는 것이 우선이다.

나에게 이런 문제 생겼던 이유는, Main problem을 해결하겠다는 생각으로 동적계획법에 접근하는 순간 수 많은 반례들이 생기며 이것을 해결하려다보면 동적계획법이 아닌 완전 탐색같은 방향으로 가기 때문이었다.

그러니 중요한 것은 컴퓨터에게 '얘야, 이런 논리가 반복해서 나타날 건데, 나를 좀 도와주렴'이라고 말할 수 있도록 '반복'되는 '논리(점화식)'를 세워야하는 것에 초점을 두는 것이었다.

이를 위해 필요한 것은 당장 구해야하는 해답을 찾으려 하는 것이 아닌, 이 해답을 위해 필요한 반복되는 수치들을 명확히 정의하는 것이다.

### 2. 분할 정복

#### 1) 분할 정복 알고리즘이란

분할정복 알고리즘은 문제를 '나눌 수 없을 때까지' 나누어서 푼 뒤, 다시 '합병'해서 문제의 답을 얻는 알고리즘이다.

이 부분에서 이미 동적계획법과는 차이가 조금 있음을 알 수 있다.

또한, 문제를 잘게 쪼갤 때, 부분 문제는 서로 중복되지 않기 때문에 Memoization도 없다.

이를 이용해서 '병합 정렬', '퀵 정렬'등을 수행할 수 있다.

#### 2) 분할 정복 알고리즘의 이해

글로만 읽으니 감은 잡히는데, 실제로 습득은 어려운 것 같아서 백준에서 가장 쉬운 분할 정복 알고리즘을 뜯어보기로 했다.

#### 3) 2630번 색종이 만들기

##### 문제

문제는 이러하다. (세부 사항은 백준 참고)

https://www.acmicpc.net/problem/2630

2의 거듭제곱(지수 k는 1 <= k <= 7의 자연수)을 한 변의 길이로 가지는 종이는, 변의 길이를 1로 가지는 하얀색 혹은 파란색 칸으로 구성되어있다.

이 종이를 같은 색을 공유하는 칸끼리 구성된 '정사각형'으로 남을 때까지 자른다.

이때 나눠진 파란색 정사각형과 하얀색 정사각형의 갯수를 출력하라.

##### 문제 접근이전

보자마자 생각해볼 수 있던 것은 종이를 정사각형이 될때까지 자르고, 정사각형이 되었을 때 갯수들을 병합해서 해를 구하는 방식이었다.

아직 알고리즘을 모른채로 고민하는 것은 효율적이지 못하기 때문에, 일단은 다른 사람들의 여러 풀이를 보면서 핵심을 이해해보기로 했다.

###### 쿼드트리

풀이를 찾다보니 하나의 종이를 4개의 분면으로 나눈다는 것이었는데, 이것에 대해 더 찾아보니 '쿼드 트리'라는 것도 알게되었다.

쿼드트리란, 트리를 기반으로 자식노드가 4개인 트리를 의미한다고 한다.

이는 대량의 좌표 데이터를 메모리 안에 압축 저장하기 위해 사용하는 여러 기법 중에 하나라고 한다. 이런 3D 데이터를 표현하기 위한 자료구조들을 '장면 그래프'라고 한다고 한다.

이 외에도 이진트리, 옥트리(8개) 등이 존재한다.

(지식이 늘었다!)

##### 풀이

각 색을 공유하는 색종이의 넓이를 구하는 것이 아니라 색을 공유하는 정사각형의 수를 모두 구하는 문제이기 때문에, 4개의 분면으로 쪼개고 각 분면들이 같은 색을 공유하면 해당 색의 count를 + 1하며 재귀 함수를 종료하는 식으로 접근하는 것이 효율적이고 심플하지 않을까 생각해볼 수 있었다.

#### 4) 1992번 쿼드트리

##### 문제

https://www.acmicpc.net/problem/1992

##### 풀이

위의 색종이 만들기와 같았다.

다만, 실행 스택을 고려해서 괄호를 열고 닫아주기만 하면 됐다.
