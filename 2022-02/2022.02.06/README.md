처음에 접근했던 방식은

1. 순열을 전부 구한다.
2. 규칙에 대입시킨다.
3. 맞으면 출력 후 정지.

이것이었는데, 최악의 경우 순열의 경우의 수가 20! / 10! 만큼 나왔다.

먼저 규칙을 구한 뒤, 거기에 맞게 dfs를 돌리는 것이 더 맞아보였다.

앞서 풀었던 부등호 문제처럼, 규칙을 통해서 수의 대소 비교를 미리 구한 뒤 그걸 토대로 수를 구하는 것이 더욱 효율적이라고 판단되었다.

그럼 코드는 크게

1. 규칙을 구한다.
2. 규칙을 토대로 dfs를 돌린다.

이렇게 나눠볼 수 있었다.

1. 규칙을 구한다.

- signs 배열을 만들어서 s[i][j]의 형태로 접근이 쉽도록 나눈다.
- signs[i][j]에 접근해서, A[i]와 A[j]의 총합을 통해서 A[i]와 A[j]에 접근한다.
- 경우의 수를 줄여나간다.

그런데 생각해보니, 규칙을 찾는다는 것도 코드가 너무 복잡해졌다.

순열을 구하면서, 하나씩 규칙에 대입시키고 틀리면 중지시키는 백트래킹 쪽이 더 맞아보였다.

하나씩 규칙에 대입하기 위해, N번째의 수부터 첫번째 수까지 역순으로 구하는 방법으로 풀었는데, 역순으로 설계를 해두니 틀렸을때 어느 부분을 고쳐야하는지 감이 오지 않았다.

오늘의 교훈 : 나는 천재가 아니기 때문에, 처음에 코드를 설계할때 최대한 간결하게 설계해야 후에 문제를 파악할때도 훨씬 편하다. 머리가 나쁘면 몸이 고생한다.
