// 숨바꼭질 3

이전 숨바꼭질 문제에서 visited로 답을 내는 방식 대신, willVisit 배열에 지난 시간을 포함하는 배열을 추가하는 방식으로 수정하려 했으나, 시간 초과가 나왔다.

다른 bfs와 달리 범위가 넓어서 그런 것 같다.

백트래킹을 사용해서 작업양을 좀 줄여주면 될 것 같다.

계속 알 수 없는 부분에서 카운팅이 더 되고 있었는데, 알고보니 visited[point * 2] = visited[point]; 라는 문에서 참조에 대한 복사가 일어나고 있었다.

깊은 복사를 할 수 있도록 코드를 짤까 했는데, visited[point * 2]의 순서를 맨 위로 올려서 간단히 해결할 수 있었다.

무언가 잘못됨을 느껴서 질문 검색을 찾아보니 이 문제는 단순 bfs가 아닌, dikstra 알고리즘이나 0-1 bfs를 사용해야한다고 했다. 지식이 늘었다.

0-1 bfs를 사용하기 위해서 unshift를 사용해봤으나, 범위가 100000까지인 문제에서 어림도 없었다.

class로 Deque을 구현해서 사용했다.

class로 Deque을 구현할때, 이전에는 배열을 이용해서 했었는데 이번에는 시간 복잡도 때문에 node class를 이용한 구현을 해볼 수 있었다. 내일은 이것을 조금 더 깊게 파서 Deque 문제를 새로 풀어봐야겠다.

// unshift로 풀었다.
x \* 2일때도 방문처리를 하는 것이 시간 단축에 더 도움이 되었다. 나도 모르겠다. 이건 좀 더 생각해봐야겠다.
